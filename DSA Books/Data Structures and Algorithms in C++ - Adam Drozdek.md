1. **Object-Oriented Programming using C++**
	1. Abstract Data Types
	2. Encapsulation
	3. Inheritance
	4. Pointers
	5. Polymorphism
	6. C++ and OOP
	7. The Standard Template Library
	8. Vectors in the STL
	9. Data Structures and OOP
	10. Case Study: Random Access File
2. **Complexity Analysis**
	1. Computational and Asymptotic Complexity
	2. Big-O Notation
	3. Properties of Big-O Notation
	4. Omega and Theta Notations
	5. Possible Problems
	6. Examples of Complexities
	7. Finding Asymptotic Complexity
	8. The Best, Average and Worst Case
	9. Amortized Complexity
	10. NP-Completeness
3. **Linked Lists**
	1. Singly Linked List
	2. Doubly Linked List
	3. Circular Lists
	4. Skip Lists
	5. Self-Organizing Lists
	6. Sparse Tables
	7. Lists in the STL
	8. Concluding Remarks
	9. Case Study: A Library
4. **Stacks and Queues**
	1. Stacks
	2. Queues
	3. Priority Queues
	4. Stacks in the STL
	5. Queues in the STL
	6. Priority Queues in the STL
	7. Deques in the STL
	8. Case Study: Exiting a Maze
5. **Recursion**
	1. Recursive Definistions
	2. Function calls and Recursion Implementation
	3. Anatomy of a Recursive Call
	4. Tail Recursion
	5. Non-Tail Recursion
	6. Nested Recursion
	7. Excessive Recursion
	8. Backtracking
	9. Concluding Remarks
	10. Case Study: A Recursive Descent Interpreter
6. **Binary Trees**
	1. Trees, Binary Trees and Binary Search Trees
	2. Implementing Binary Trees
	3. Searching a Binary Search Trees
	4. Tree Traversal
	5. Insertion
	6. Deletion
	7. Balancing a Tree
	8. Self-Adjusting Trees
	9. Heaps
	10. Treaps
	11. K-d Trees
	12. Polish Notations and Expression Trees
	13. Case Study: Computing Word Frequencies
7. **Multiway Trees**
	1. The Family of B-Trees
	2. Tries
	3. Concluding Remarks
	4. Case Study: Spell Checker
8. **Graphs**
	1. Graph Representation
	2. Graph Traversals
	3. Shortest Paths
	4. Cycle Detection
	5. Spanning Trees
	6. Connectivity
	7. Topological Sort
	8. Networks
	9. Matching
	10. Eulerian and Hamiltonian Graphs
	11. Graph Coloring
	12. NP-Complete Problems in Graph Theory
	13. Case Study: Distinct Representation
9. **Sorting**
	1. Elementary Sorting Algorithms
	2. Decision Trees
	3. Efficient Sorting Algorithms
	4. Sorting in the STL
	5. Case Study: Adding Polynomials
10. **Hashing**
	1. Hash Functions
	2. Collision Resolution
	3. Deletion
	4. Perfect Hash Functions
	5. Rehashing
	6. Hash Functions for Extendible Files
11. **Data Compression**
	1. Conditions for Data Compression
	2. Huffman Coding
	3. Run-Length Encoding
	4. Ziv-Lempler Code
	5. Case Study: Huffman Method with Run-Length Encoding
12. **Memory Management**
	1. The Sequential-Fit Methods
	2. The Nonsequential-Fit Methods
	3. Garbage Collection
	4. Case Study: An In-Place Garbage Collector
13. **String Matching**
	1. Exact String Matching
	2. Approximate String Matching
	3. Case Study: Longest Common Substring
14. **Appendixes**
	1. Computing Big-O
	2. Algorithms in Standard Template Library
	3. NP-Completeness