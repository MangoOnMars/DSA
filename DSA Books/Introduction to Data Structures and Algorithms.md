1. **RAM Model**
	1. Pseudo Code
	2. Analyzing Algorithms
	3. Logarithms & Exponentials
	4. Representing Arrays
	5. Basic Approach to Algorithm Design
2. **Lists**
	1. Array Implementation of Stacks
	2. Array Implementation of Queues
	3. General Purpose Lists
	4. Representing Lists With Pointers
	5. Implementation of the Basic List Operations in O(1) Time
3. **Induction & Recursion**
	1. Binary Search
	2. Traversing Linked Lists
	3. Fast Computation of Integer Exponents
	4. Proof by Induction
	5. Elimination of Recursion
4. **Trees**
	1. Tree Terms
	2. Representing Trees
	3. Pre-Order Traversal
	4. Level-Order traversal
	5. Binary Search Trees
	6. The Rotation Operation for Binary Search Trees
	7. Self-Adjusting Binary Search Trees
5. **Algorithm Design**
	1. Divide and Conquer
	2. Divide and Conquer Recurrence Relations
	3. Dynamic Programming
	4. Dynamic Programming Sums
	5. Randomized Algorithms
	6. Greedy Algorithms
6. **Hashing**
	1. Basic Hashing Algorithm
	2. Hash Functions for Data Items with Many Bits
	3. Complexity of Hashing
	4. The Constant e
	5. Expected Number of Empty Bucketes
	6. Chernoff Bound
	7. Size of the Largest Bucket
	8. Overfilling a Hash Table
	9. Resizing a Hash Table
	10. Universal Hashing
	11. Twin Hashing
	12. Bloom Filters
7. **Heaps**
	1. Complete k-ary Trees
	2. Full k-ary Trees
	3. Heap Implementation with Full Trees
	4. Building a Heap in Linear Time
	5. Heap Sort
	6. Implementing Heaps with Pointers
	7. Lower Bounds on Heap Operations and Sorting
8. **Balanced Trees**
	1. 2-3 Trees
	2. Red-Black Trees
	3. AVL Trees
	4. Storing Data Only in Leaves
9. **Sets Over a Small Universe**
	1. In-Place Permutation
	2. Bucket Sorting
	3. Bit-Vector Representation of Sets
	4. Union-Find Problem
10. **Graphs**
	1. Graph Terms
	2. Representing Graphs
	3. Depth-First Search
	4. Breath-First Search
	5. Depth-First Spanning Trees
	6. Bi-Connected and Strongly-Connected Components
	7. Minimum Weight Spanning Trees
	8. Topological Sort of a Directed Graph
	9. Euler Paths
	10. Single-Source Minimum Cost Path
	11. All Paris Minimum Cost Paths
	12. Maximum Flow
	13. Maximum Matching
	14. Stable Marriage
	15. NP-Complete Graph Problems
11. **Strings**
	1. Lexicographic Sorting of Strings
	2. Knuth-Morris-Pratt (KMP) String Matching
	3. Boyer-Moore String Matching
	4. Karp-Rabin Randomized "Finger Print" String Marching
	5. Shift-And-String Matching
	6. Comparison of String Marching Methods
	7. Pattern Marching
	8. Tries
	9. Compact Tries
	10. Suffix Tries
	11. Sliding Suffix Tries
	12. Edit Distance: A Measure of String Similarity
	13. Arithmetic Codes
	14. The Burrows-Wheeler Transform
12. **Discrete Fourier Transform**
	1. Complex Numbers
	2. Complex Exponentials
	3. Principal nth Root of Unity
	4. Definition of DFT
	5. F and G and Inverse Functions
	6. Similarity of F and G
	7. How to Split F into Two Computations of Half the Size
	8. Divide and Conquer "Butterfly"
	9. Recursive FFT Algorithm
	10. In-Place Bit Reversal
	11. Recursive In-Place FFT Algorithm
	12. Non-Recursive In-Place FFT Algorithm
	13. Simplified Non-Recursive In-Place FFT Algorithm
	14. DFT over Finite Fields on an Array of Integers
	15. Fast Convolutions with the DFT
	16. DFT on 2 arrays of Reals
	17. DFT on a single array of reals
	18. inverse DFT for reals
	19. Discrete Cosine Transform
	20. C and D are Inverse Functions
	21. DCT Basis Functions
	22. Relationship of teh DCT to the DFT
	23. Computing the DCT in O(nlog(n)) time
	24. Computing the Inverse DCT in O(nlog(n)) time
	25. Two Dimensional DFT and DCT
13. **Parallel Computation**
	1. Brent's Lemma
	2. PRAM Simulatino
	3. EREW PRAM MODEL
	4. Hypercube / CCC / Butterfly Networks
	5. Mesh Network
	6. Area-Time Tradeoffs
14. **Appendix: Common Sums**
	1. Approximating Sums with Integrals
	2. Arithmetic Sum
	3. Simple Geometric Sum
	4. Linear Weighted Geometric Sum
	5. Quadratic Weighted Geometric Sum
	6. Cubic Weighted Geometric Sum
	7. Harmonic Sum
	8. Sums of Inverse Powers